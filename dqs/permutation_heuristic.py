'''
Functions used to heuristically select a simulation order for the cliques
generated by a MIN-CLIQUE-COVER. The heuristic uses information stored in
the commutation graph to construct a binary tree which gives a specific
permutation when traversed from root to a leaf.
'''


class Node:

    def __init__(self,  data, score, choices, inter_edges):
        self.data = data     # A clique label (A,B,C,...)
        self.score = score   # Number of inter-clique edges between this node and its parent
        self.choices = choices # Remaining cliques to be added
        self.inter_edges = inter_edges # Dictionary storing the inter-clique edge data
        self.right = None    # right child
        self.left = None     # left child

    def gen_tree(self):
        # Once the root is specified, all of the data is present to grow the rest of the tree
        if len(self.choices) == 1:
            # If only 1 clique remains in the possible choices,
            # set this node's left child to be that clique
            data = self.choices[0]
            score = self.inter_edges[self.data][data]
            self.left = Node(data, score, [], self.inter_edges)
        elif len(self.choices) > 1:
            # If there is more than 1 clique available,
            # gather the possible choices, and their scores (from this clique -> c)
            nextnodes = [(c, self.inter_edges[self.data][c]) for c in self.choices]
            # sort the choices by score (High -> Low)
            nextnodes = sorted(nextnodes, key=lambda s: s[1], reverse=True)

            # Choose the highest score to be the left child
            leftchoices = [n for n in self.choices if n != nextnodes[0][0]]
            self.left = Node(nextnodes[0][0], nextnodes[0][1], leftchoices, self.inter_edges)
            self.left.gen_tree()

            # Choose the second highest score to be the right child
            rightchoices = [n for n in self.choices if n != nextnodes[1][0]]
            self.right = Node(nextnodes[1][0], nextnodes[1][1], rightchoices, self.inter_edges)
            self.right.gen_tree()


    def PrintTree(self):
        if not self.left is None:
            self.left.PrintTree()
        print(self.data, self.score, self.choices)
        if not self.right is None:
            self.right.PrintTree()


def allRootToLeaf(root):
    '''
    Given the root node, traverse all root->leaf paths and compute the
    connection score associated with that path.
    '''
    if root is None:
        return []
    if (root.left == None and root.right == None):
        return [(root.data, root.score)]

    left_subtree = allRootToLeaf(root.left)
    right_subtree = allRootToLeaf(root.right)
    full_subtree = left_subtree + right_subtree
    #print('full_subtree:', full_subtree)

    path_list = []
    for child_path in full_subtree:
        path_list.append((root.data + child_path[0], root.score+child_path[1]))

    return path_list


def check_commutativity(term1, term2):
    '''
    if [term1, term2] = 0, return True
    otherwise, return False
    '''
    diff = 0
    for c1, c2 in zip(term1, term2):
        if c1 != 'I' and c2 != 'I' and c1 != c2:
            diff += 1
    if diff % 2 == 0:
        return True
    else:
        return False


def commutation_score(cliques, permutation, connect_score):
    '''
    Given two cliques:
        A = l1*P1 + l2*P2 + ... + lN*PN
        B = m1*Q1 + m2*Q2 + ... + mM*QM

    They will have a connection score, C_s, equal to the number of edges between
    them in the commutation graph.

    The commutation score can be computed as:

              Sum_i (Sum_j (|l_i*m_j|)) / C_s
    '''
    comm_score = 0
    for i in range(len(permutation) - 1):
        cliq1 = cliques[permutation[i]]
        cliq2 = cliques[permutation[i+1]]
        for term1 in cliq1:
            for term2 in cliq2:
                if not check_commutativity(term1[1], term2[1]) and connect_score > 0:
                    comm_score += abs(float(term1[0])*float(term2[0])) / connect_score
    return comm_score


def gen_heuristic(original_cliques):
    if len(original_cliques) == 1:
        return original_cliques

    # label the cliques
    cliques = {}
    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    for i, clique in enumerate(original_cliques):
        cliques[alphabet[i]] = clique

    # collect number of inter-clique edges
    inter_edges = {}
    for key1 in cliques.keys():
        dat = {}
        for key2 in cliques.keys():
            if key1 != key2:
                count = 0
                for term1 in cliques[key1]:
                    for term2 in cliques[key2]:
                        if check_commutativity(term1[1], term2[1]):
                            count += 1
                dat[key2] = count
        inter_edges[key1] = dat
    #print('inter_edges:',inter_edges)

    # generate high connection score permutations
    perm_trees = []
    for key in cliques.keys():
        choices = [k for k in cliques.keys() if k != key]
        root = Node(key, 0, choices, inter_edges)
        root.gen_tree()
        perm_trees.append(root)
    #print(perm_trees)
    #perm_trees[1].PrintTree()

    connect_perms = []
    for tree in perm_trees:
        connect_perms.extend(allRootToLeaf(tree))
    #connect_perms = sorted(connect_perms, key=lambda p: p[1], reverse=True)
    #print(connect_perms)
    #print(len(connect_perms))

    # for each of the connection-score-permutations generated, compute the commutation score
    heuristic = []
    for perm in connect_perms:
        heuristic.append((perm[0], perm[1], commutation_score(cliques, perm[0], perm[1])))
    heuristic = sorted(heuristic, key=lambda p: p[1], reverse=True)

    # print top 5 best connection scores
    #print(sorted(heuristic, key=lambda p: p[1], reverse=True)[0:5])
    # print top 5 commutation scores
    #print(sorted(heuristic, key=lambda p: p[2])[0:5])

    # Out of all the connection scores choose the lowest commutation score
    final = sorted(heuristic[0:-1], key=lambda p: p[2], reverse=False)
    result = final[0]
    # print('Heuristic result:',result)

    # construct the sorted Hamiltonian with the given permutation
    sortedH = []
    for cliq in result[0]:
        sortedH.append(cliques[cliq])
    return sortedH









